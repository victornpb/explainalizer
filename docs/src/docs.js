
/*
copy(`'${document.querySelector('h1').innerText.match(/.* - (.*)/)[1]}' : {
    text: \`${document.querySelector('.long-content p:nth-child(2)').innerText}\`,
    link: '${location.href}',
},\n`)
*/

export default {
    // Scan nodes
    'Seq Scan': {
        text: `This is the simplest way of fetching data from a table: it scans through every page of data sequentially. Like most other scans, this can apply a filter while reading data, but it needs to read the data first and then discard it. A sequential scan has no way to zero in on just the data you want: it always reads everything in the table. This is generally inefficient unless you need a large proportion of the table to answer your query, but is always available and sometimes may be the only option.`,
        link: 'https://pganalyze.com/docs/explain/scan-nodes/sequential-scan',
    },
    'Index Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/index-scan',
        text: `An index scan uses an index to find either a specific row, or all rows matching a predicate. An index scan will either look up a single row at a time (for a query like WHERE id = 1234, or as the inner table in a nested loop, looking up the row matching the current outer row), or scan through a section of the table in order. An index scan must first look up each row in the index, and then check the actual table data for that index entry. The table data must be checked to ensure that the row it found is actually visible to the current transaction, and also to fetch any columns included in the query that are not present in the index. Because of this, an index scan actually has higher per-row overhead than a sequential scan: its real advantage is that it allows you to read only some of the rows in a table. If your query predicate is not very selective (that is, if few rows are filtered out), a sequential scan may still be more efficient than an index scan.

        If your query predicate matches the index exactly, the scan will retrieve just the matching rows. If you have an additional predicate in your query, the index scan can filter rows as it’s reading them, just like a sequential scan.`,
    },
    'Index Only Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/index-only-scan',
        text: `This is very similar to an Index Scan, but the data comes directly from the index and the visibility check is handled specially, so it can avoid looking at the table data entirely. An index-only scan is faster, but it’s not always available as an alternative to a regular index scan. It has two restrictions: the index type must support Index-Only Scans (the common btree index type always does) and (somewhat obviously) the query must only project columns included in the index. If you have a SELECT * query but don’t actually need all columns, you may be able to use an index-only scan just by changing the column list.`,
    },
    'Bitmap Heap Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/bitmap-heap-scan',
        text: `A bitmap heap scan takes a row location bitmap generated by a Bitmap Index Scan (either directly, or through a series of bitmap set operations via BitmapAnd and BitmapOr nodes) and looks up the relevant data. Each chunk of a bitmap can either be exact (pointing directly to rows) or lossy (pointing to a page containing at least one row matching the predicate).

        Postgres prefers using exact blocks, but if limited work_mem is an issue, it will start using lossy blocks as well. The blocks are actually produced as lossy or exact by children of the bitmap heap scan, but that status is more relevant when the blocks are processed to fetch rows, so it is reflected in the Bitmap Heap Scan. If a bitmap block is lossy, the node will need to fetch the entire page, and re-check the specified index condition (since it doesn’t know which rows on the page are needed).`,
    },
    'Bitmap Index Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/bitmap-index-scan',
        text: `You can think of a bitmap index scan as a middle ground between a sequential scan and an index scan. Like an index scan, it scans an index to determine exactly what data it needs to fetch, but like a sequential scan, it takes advantage of data being easier to read in bulk.

        The bitmap index scan actually operates in tandem with a Bitmap Heap Scan: it does not fetch the data itself. Instead of producing the rows directly, the bitmap index scan constructs a bitmap of potential row locations. It feeds this data to a parent Bitmap Heap Scan, which can decode the bitmap to fetch the underlying data, grabbing data page by page.
        
        A Bitmap Heap Scan is the most common parent node of a Bitmap Index Scan, but a plan may also combine several different Bitmap Index Scans with BitmapAnd or BitmapOr nodes before actually fetching the underlying data. This allows Postgres to use two different indexes at once to execute a query.`,
    },
    'CTE Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/cte-scan',
        text: `Scan the result of a common table expression. Note that until Postgres 12, common table expressions are an optimization fence; the CTE result is materialized, and is essentially treated as a temporary table and not optimized as part of the query. If you depend on this behavior, be aware performance of your queries may change when you upgrade.`,
    },
    'Custom Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/custom-scan',
        text: `Scan using a custom scan implementation, which can be added as a separate module and plug into standard Postgres query planning and execution.`,
    },
    'Foreign Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/foreign-scan',
        text: `Scan on a Foreign Table.`,
    },
    'Function Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/function-scan',
        text: `Scans the result of a set-returning function (like unnest or regexp_split_to_table).`,
    },
    'Subquery Scan': {
        text: `A Subquery Scan is for scanning the output of a sub-query in the range table. We often need an extra plan node above the sub-query's plan to perform expression evaluations (which we can't push into the sub-query without risking changing its semantics).`,
        link: 'https://pganalyze.com/docs/explain/scan-nodes/subquery-scan'
    },
    'Table Sample Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/table-sample-scan',
        text: `Scan a table when the TABLESAMPLE feature is used. Note that this clause does change the semantics of your query, but if you’re looking to gather some statistics about data in a large table, it can be a lot more efficient than a full sequential scan.`,
    },
    'Tid Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/tid-scan',
        text: `Similar to an Index Scan, but one that can only look up rows using the internal and unstable ctid identifier. You are unlikely to use this type of scan in your queries.`,
    },
    'Values Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/values-scan',
        text: `Scan the literal VALUES clause.`,
    },
    'Work Table Scan': {
        link: 'https://pganalyze.com/docs/explain/scan-nodes/work-table-scan',
        text: `Scans the work table used in evaluating a recursive common table expression.`,
    },

    // Join Nodes
    'Hash Join': {
        link: 'https://pganalyze.com/docs/explain/join-nodes/hash-join',
        text: `Build a hash table from the inner table, keyed by the join key. Then scan the outer table, checking if a corresponding value is present. If the hash table would exceed work_mem, this process needs to happen in several batches writing temporary files to disk, which becomes dramatically slower.`,
    },
    'Merge Join': {
        link: 'https://pganalyze.com/docs/explain/join-nodes/merge-join',
        text: `Joins two children already sorted by their shared join key. This only needs to scan each relation once, but both inputs need to be sorted by the join key first (or scanned in a way that produces already-sorted output, like an index scan matching the required sort order).`,
    },
    'Nested Loop Join': {
        link: 'https://pganalyze.com/docs/explain/join-nodes/nested-loop',
        text: `For each row in the outer table, iterate through all the rows in the inner table and see if they match the join condition. If the inner relation can be scanned with an index, that can improve the performance of a Nested Loop Join. This is generally an inefficient way to process joins but is always available and sometimes may be the only option.`,
    },

    // Other Nodes
    'Aggregate': {
        link: 'https://pganalyze.com/docs/explain/other-nodes/aggregate',
        text: `An Agg node implements plain or grouped aggregation. For grouped aggregation, Postgres can work with presorted input or unsorted input; the latter strategy uses an internal hashtable.`,
    },
    'Append': {
        text: `Generate the concatenation of the results of sub-plans. For example, this can be used for a UNION ALL query.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/append',
    },
    'Append': {
        text: `Generate the concatenation of the results of sub-plans. For example, this can be used for a UNION ALL query.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/append',
    },
    'Bitmap And': {
        text: `Generate a bitmap of the intersection of two physical row location bitmaps (that is, only locations that occur in both bitmaps). The bitmaps can come from Bitmap Index Scans or other BitmapOr or BitmapAnd child nodes.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/bitmap-and',
    },
    'Bitmap Or': {
        text: `Generate a bitmap of the union of two physical row location bitmaps (that is, locations that occur in either bitmap). The bitmaps can come from Bitmap Index Scans or other BitmapOr or BitmapAnd child nodes.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/bitmap-or',
    },
    'Gather Merge': {
        text: `Merge the results of pre-sorted worker outputs—similar to the Merge Append node.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/gather-merge',
    },
    'Gather': {
        text: `Gather data from multiple workers—similar to the Append node.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/gather',
    },
    'Group': {
        text: `Used for queries with GROUP BY (but no aggregates) specified. The input must be presorted according to the grouping columns.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/group',
    },
    'Hash': {
        text: `Reads data into a hash table, where it can easily be looked up by the hash key. This is used for hash joins and hash aggregates.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/hash',
    },
    'Limit': {
        text: `Takes data from a child node and produces sorted output, using either memory if available (depending on the work_mem setting) or “spilling” to disk. This is obviously necessary if the output needs to be sorted, though sometimes the input can be scanned in an already-sorted manner instead—e.g., if scanning a btree index compatible with the desired sort order.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/limit',
    },
    'Lock Rows': {
        text: `Executes the locking behavior of a FOR UPDATE clause.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/lock-rows',
    },
    'Materialize': {
        text: `Materialize the result of its child node in memory (to avoid re-computing the values).`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/materialize',
    },
    'Merge Append': {
        text: `Merge the results of pre-sorted sub-plans to preserve the ordering.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/merge-append',
    },
    'Modify Table (Delete, Insert, Update)': {
        text: `Apply rows produced by a subplan to a result table by inserting, updating, or deleting rows corresponding to the input.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/modify-table',
    },
    'Project Set': {
        text: `Apply a projection that includes set-returning functions to the output tuples of the outer plan.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/project-set',
    },
    'Recursive Union': {
        text: `Generate a recursive union of two sub-plans. This is used in evaluating recursive common table expressions.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/recursive-union',
    },
    'Result': {
        text: `If no outer plan, evaluate a variable-free targetlist. If outer plan, return tuples from outer plan (after a level of projection as shown by targetlist). If resconstantqual isn't NULL, it represents a one-time qualification test (i.e., one that doesn't depend on any variables from the outer plan, so needs to be evaluated only once).`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/result',
    },
    'SetOp': {
        text: `Combines two datasets for set operations like UNION, INTERSECT, and EXCEPT. Note that the query structure for SetOps is different than you may expect: rather than being the direct parent of the sets on which it operates, a SetOp node only has a single Append child, which has a Subquery Scan for each node to combine.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/set-op',
    },
    'Sort': {
        text: `Takes data from a child node and produces sorted output, using either memory if available (depending on the work_mem setting) or “spilling” to disk. This is obviously necessary if the output needs to be sorted, though sometimes the input can be scanned in an already-sorted manner instead—e.g., if scanning a btree index compatible with the desired sort order.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/sort',
    },
    'Unique': {
        text: `Like the UNIX command uniq, takes sorted input and eliminates adjacent duplicates. Useful for DISTINCT clauses if the input is already sorted (e.g., the query also includes an ORDER BY).`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/unique',
    },
    'Window Aggregate': {
        text: `Implements aggregation in window functions.`,
        link: 'https://pganalyze.com/docs/explain/other-nodes/window-aggregate',
    },
};